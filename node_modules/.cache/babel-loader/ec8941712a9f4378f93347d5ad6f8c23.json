{"ast":null,"code":"import _toConsumableArray from \"/Users/aban.domingo/Desktop/CPSC431/431-Final/abandomingo.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nvar updateQueue = makeQueue();\nvar raf = function raf(fn) {\n  return schedule(fn, updateQueue);\n};\nvar writeQueue = makeQueue();\nraf.write = function (fn) {\n  return schedule(fn, writeQueue);\n};\nvar onStartQueue = makeQueue();\nraf.onStart = function (fn) {\n  return schedule(fn, onStartQueue);\n};\nvar onFrameQueue = makeQueue();\nraf.onFrame = function (fn) {\n  return schedule(fn, onFrameQueue);\n};\nvar onFinishQueue = makeQueue();\nraf.onFinish = function (fn) {\n  return schedule(fn, onFinishQueue);\n};\nvar timeouts = [];\nraf.setTimeout = function (handler, ms) {\n  var time = raf.now() + ms;\n  var cancel = function cancel() {\n    var i = timeouts.findIndex(function (t) {\n      return t.cancel == cancel;\n    });\n    if (~i) timeouts.splice(i, 1);\n    __raf.count -= ~i ? 1 : 0;\n  };\n  var timeout = {\n    time: time,\n    handler: handler,\n    cancel: cancel\n  };\n  timeouts.splice(findTimeout(time), 0, timeout);\n  __raf.count += 1;\n  start();\n  return timeout;\n};\nvar findTimeout = function findTimeout(time) {\n  return ~(~timeouts.findIndex(function (t) {\n    return t.time > time;\n  }) || ~timeouts.length);\n};\nraf.cancel = function (fn) {\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\nraf.sync = function (fn) {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\nraf.throttle = function (fn) {\n  var lastArgs;\n  function queuedFn() {\n    try {\n      fn.apply(void 0, _toConsumableArray(lastArgs));\n    } finally {\n      lastArgs = null;\n    }\n  }\n  function throttled() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n  throttled.handler = fn;\n  throttled.cancel = function () {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n  return throttled;\n};\nvar nativeRaf = typeof window != \"undefined\" ? window.requestAnimationFrame : function () {};\nraf.use = function (impl) {\n  return nativeRaf = impl;\n};\nraf.now = typeof performance != \"undefined\" ? function () {\n  return performance.now();\n} : Date.now;\nraf.batchedUpdates = function (fn) {\n  return fn();\n};\nraf.catch = console.error;\nvar ts = -1;\nvar sync = false;\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n    nativeRaf(loop);\n  }\n}\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\nfunction update() {\n  var prevTs = ts;\n  ts = raf.now();\n  var count = findTimeout(ts);\n  if (count) {\n    eachSafely(timeouts.splice(0, count), function (t) {\n      return t.handler();\n    });\n    __raf.count -= count;\n  }\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\nfunction makeQueue() {\n  var next = new Set();\n  var current = next;\n  return {\n    add: function add(fn) {\n      __raf.count += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n    delete: function _delete(fn) {\n      __raf.count -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n    flush: function flush(arg) {\n      if (current.size) {\n        next = new Set();\n        __raf.count -= current.size;\n        eachSafely(current, function (fn) {\n          return fn(arg) && next.add(fn);\n        });\n        __raf.count += next.size;\n        current = next;\n      }\n    }\n  };\n}\nfunction eachSafely(values, each) {\n  values.forEach(function (value) {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\nvar __raf = {\n  count: 0,\n  clear: function clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    __raf.count = 0;\n  }\n};\nexport { __raf, raf };","map":{"version":3,"mappings":"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","names":["updateQueue","makeQueue","schedule","fn","raf","write","writeQueue","onStart","onStartQueue","onFrame","onFrameQueue","onFinish","onFinishQueue","setTimeout","now","ms","cancel","timeouts","findIndex","t","i","splice","__raf","count","time","handler","findTimeout","timeout","start","length","delete","sync","batchedUpdates","throttle","lastArgs","args","queuedFn","throttled","window","requestAnimationFrame","use","nativeRaf","impl","performance","Date","catch","console","error","queue","add","ts","loop","update","eachSafely","flush","prevTs","Math","min","Set","next","current","has","size","arg","values","forEach","each","value","e","clear"],"sources":["../src/raf.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}